# -*- coding: utf-8 -*-
"""exnp2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Zu8sI3J8axTBoZhyC7fxJGfEi6Fitues
"""

# numpy 기본 연습
import numpy as np

ss = ['tom', 'james', 'oscar']
print(ss, type(ss)) # <class 'list'>
ss2 = np.array(ss)
print(ss2, type(ss2)) # <class 'numpy.ndarray'>

# 메모리 사용에 대한 비교(list vs numpy)
li = list(range(1, 10))
print(li)
print(id(li[0]), id(li[1])) # 주소가 다름
print(li * 10)
print('*' * 10)

# li 각 요소에 10곱하기
for i in li:
  print(i * 10, end = " ")

num_arr = np.array(li)
print(num_arr)
print(id(num_arr[0]), id(num_arr[1])) # 주소가 같음
print(num_arr * 10) # [10 20 30 40 50 60 70 80 90] 바로 계산됨

#a = np.array([1, 2, 3])
#a = np.array([1, 2, '3'])
#a = np.array([1, 2, 3.]) # 요소에 다양한 값이 있는 경우에는, 상위 타입을 모든 데이터가 따른다. int -> float -> complex -> str
a = np.array([1, 2, 3.], dtype = 'float32')
print(a, type(a), a.dtype) # dtype은 형식과 비트
print(a.shape, a.ndim, a.size) # shape는 차원의 크기, ndim 몇차원인지, 요소의 총갯수 size
print(a[0], a[1], a[2])
a[0] = 7
print(a)

b = np.array([[1,2,3], [4,5,6]])
print(b.shape)               # (2, 3)
print(b[0], b[0][0], b[[0]]) # [1 2 3]    1    [[1 2 3]]
print()
c = np.zeros((2, 2)) # 행,열 값
print(c)
d = np.ones((2, 2))
print(d)
e = np.full((2, 2), 7)
print(e)
f = np.eye(3) # 단위행렬
print(f)

# 난수
np.random.seed(0)
print(np.random.rand(5)) # 균등분포를 따르는 0 ~ 1 사이의 난수 발생
print(np.random.randn(2, 2)) # 정규분포를 따르는 0 ~ 1 사이의 난수 발생
print(np.random.normal(0, 1, (2, 3)))
x1 = np.random.randint(10, size = 6) # 1차원배열
x2 = np.random.randint(10, size = (3, 4)) # 2차원배열
x3 = np.random.randint(10, size = (3, 4, 5)) # 3차원배열
print(x1.ndim, x2.ndim, x3.ndim) # 몇차원인가 => ndim, 여러가지 조회가능 size, shape, itemsize, dtype
print(x1.nbytes, x2.nbytes, x3.nbytes)

print('dict type 으로 random 출력')
g = {i:np.random.randn() for i in range(5)}
print(g)

# slicing ----------------------
a = np.array([1,2,3,4,5])
print(a)
print(a[0])
print(a[1:5:2])
print(a[1:])
b = a
b[0] = 7
print(b)
print(a)
c = np.copy(a) # 복사본 생성(새로운 객체)
c[0] = 8
print(a)
print(c)

a = np.array([[1,2,3,4],[5,6,7,8],[9,10,11,12]])
print(a, a.shape)
print(a[:])
print(a[0],a[0][0], a[[0]])
print(a[0][0], a[0,0])
print(a[1:,])
print(a[1:, 0:2]) # 1행부터 0,1열만 출력
b = a[:2, 1:3]
print(b) # 서브배열 - 전체배열중 일부만 뽑아 서브로 운영할수 있는데, 값을 임의로 바꾸면 모체 배열도 바뀐다.
b[0, 0] = 77
print(b)
print(a)

a = np.array([[1,2,3], [4,5,6], [7,8,9]])
print(a.shape)
r1 = a[1, :] # a[1, ]와 같음 반환값이 1차원
r2 = a[1:2, :] # a[1:2, ] 와 같음 반환값이 2차원
print(r1, r1.shape)
print(r2, r2.shape)

# 열에 대한 접근도 ...
c1 = a[:, 1] # 반환값이 1차원
c2 = a[:, 1:2] # 반환값이 2차원
print(c1, c1.shape) 
print(c2, c2.shape)

a = np.array([[1,2,3],[4,5,6],[7,8,9], [10,11,12]])
print(a)
b = np.array([[0, 2, 0, 1]])
print(np.arange(4)) # [0,1,2,3]   b 요소로 a의 행 인덱스로 사용
print(a[np.arange(4), b]) # 0,1,2,3행의 0열, 2열, 0열, 1열
a[np.arange(4), b] += 10
print(a)
print()

bool_idx = (a > 10)
print(bool_idx)

print(a[bool_idx]) # true인 요소만 출력
print(a[a > 10])